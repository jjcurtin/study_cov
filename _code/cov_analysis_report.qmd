---
title: "Analysis of Covariate Results"
author: "Lauren Khoury"
date: "`r lubridate::today()`"
execute:
  echo: false
format: 
  html: 
    embed-resources: true
    toc: true 
    toc_depth: 5
    fig-width: 9
    fig-height: 7
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: set up

library(dplyr) |> suppressMessages()
library(skimr)
library(purrr)
library(ggplot2)
library(cowplot)
library(forcats)
library(kableExtra, exclude = ("group_rows"))

theme_set(theme_classic())
method_colors <- c("no_covs" = "sienna",
                   "all_covs" = "goldenrod2",
                   "p_hacked" = "red2",
                   "r" = "springgreen3",
                   "partial_r" = "deepskyblue",
                   "full_lm" = "mediumpurple1",
                   "lasso" = "hotpink")
method_linetypes <- c("no_covs" = "solid",
                      "all_covs" = "solid",
                      "p_hacked" = "longdash",
                      "r" = "longdash",
                      "partial_r" = "longdash",
                      "full_lm" = "longdash",
                      "lasso" = "longdash")

devtools::source_url("https://github.com/jjcurtin/lab_support/blob/main/format_path.R?raw=true") |> suppressMessages()

rdrive_path <- format_path("studydata/cov/raw_data")

options(digits = 3)

```

# Background

We ran simulations to generate data, fit linear models using different selection methods for covariates, and extract the results. In each simulation, we generated data with a dichotomous $X$. We generated the covariates and $Y$ from a multivariate normal distribution with $\mu = 0$ and a covariance matrix based on the correlation values listed below.

We manipulated the following variables:

| Variable | Description | Values |
|--------------------|--------------------|--------------------------------|
| b_x | The population parameter for $X$ | 0, 0.3, 0.5 |
| n_obs | Number of observations in a sample | 50, 100, 150, 200, 300, 400 |
| n_covs | Number of total available covariates | 4, 8, 12, 16, 20 |
| p_good_covs | Proportion of "good" covariates\* | 0.25, 0.50, 0.75 |
| r_ycov | Correlation between $Y$ and the "good" covariates | 0.3, 0.5 |
| r_cov | Correlation between the "good" covariates\* | 0.3 |

\* Note: here we define "good" covariates as ones that have a nonzero relationship with $Y$

<br> We fully crossed all levels, yielding 450 unique research settings. <br> We used the following 7 methods to select covariates to include in a linear model:

1.  No covariates
2.  All covariates
3.  P-hacking
4.  Bivariate correlation
5.  Partial correlation (including $X$ in the model)
6.  Full lm (including $X$ in the model)
7.  LASSO (including $X$ in the model)

We fit a linear model for each method and from the model output, extracted the estimate for $X$, standard error of this estimate, and p-value of this $X$ effect. <br>

We repeated this 20,000 times for each research setting. <br>

We present the results here.

# Data Analysis

## Preview data

The total amount of data simulated equals 63,000,000 observations = 450 unique research settings $\times$ 20,000 simulations each $\times$ 7 methods. We will consider the data separated by the $X$ effect. <br>

Data for $b_x = 0$, as an example, is shown below.

```{r}
#| label: read in d0

d_0 <- data.table::fread(here::here(rdrive_path, "batch_results_new_method_0.csv")) |> 
  mutate(method = factor(method, c("no_covs", "all_covs", "p_hacked", "r", 
                                   "partial_r", "full_lm", "lasso"))) |> 
  glimpse()

```

```{r}
#| label: read in d03

d_03 <- data.table::fread(here::here(rdrive_path, "batch_results_new_method_03.csv")) |> 
  mutate(method = factor(method, c("no_covs", "all_covs", "p_hacked", "r", 
                                   "partial_r", "full_lm", "lasso"))) 

```

```{r}
#| label: read in d05

d_05 <- data.table::fread(here::here(rdrive_path, "batch_results_new_method_05.csv")) |>
  mutate(method = factor(method, c("no_covs", "all_covs", "p_hacked", "r", 
                                   "partial_r", "full_lm", "lasso")))

```

```{r}
#| label: read in d20covs

d_20_covs <- data.table::fread(here::here(rdrive_path, "batch_results_20_covs.csv")) |>
  mutate(method = factor(method, c("no_covs", "all_covs", "p_hacked", "r",
                                   "partial_r", "full_lm", "lasso")))

```

```{r}
#| label: read in dn50

d_n50 <- data.table::fread(here::here(rdrive_path, "batch_results_n50.csv")) |>
  mutate(method = factor(method, c("no_covs", "all_covs", "p_hacked", "r",
                                   "partial_r", "full_lm", "lasso")))

```

```{r}
#| label: combine data

d_0 <- rbind(d_0, d_20_covs |> filter(b_x == 0))
d_03 <- rbind(d_03, d_20_covs |> filter(b_x == 0.3))
d_05 <- rbind(d_05, d_20_covs |> filter(b_x == 0.5))

d_0 <- rbind(d_0, d_n50 |> filter(b_x == 0))
d_03 <- rbind(d_03, d_n50 |> filter(b_x == 0.3))
d_05 <- rbind(d_05, d_n50 |> filter(b_x == 0.5))

```

## Zero $X$ Effect

First, we look at the zero $X$ effect condition to compare the Type I errors across methods and research settings.

### Type I error

We will look at the overall Type I error across methods, then will compare the error of each method across each of the manipulated variables: n_obs, n_covs, p_good_covs, r_ycov, and r_cov.

#### by method

We will first consider the Type I error by the selection method. Here we calculate the proportion of significant effects ($p < 0.05$), the Type I error, displayed below as a bar plot.

```{r}
#| label: fig-typeI-bar

type_I_summary <- d_0 |>
  group_by(method) |>
  summarise(type_I = mean(p_value < 0.05))

type_I_summary |> 
  mutate(method = fct_relevel(method, "p_hacked")) |>
  ggplot(aes(x = method, y = type_I, fill = method)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = 0.05, linetype = "dotted", color = "black") +
  geom_text(aes(label = sprintf("%.3f", type_I)), vjust = -0.5) +
  labs(title = "Type I error by method",
       x = "Method",
       y = "Type I Error",
       fill = "Method") +
  scale_y_continuous(limits = c(0, max(type_I_summary$type_I) * 1.2), 
                     breaks = seq(0, max(type_I_summary$type_I) * 1.2, by = 0.05)) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = method_colors)

```

From this bar plot, we see that the p-hacking method for selecting covariates leads to inflated Type I error rates. The no covariates, all covariates, and bivariate correlation ("r") approaches are all at the expected 0.05 mark ($\alpha = 0.05$), while the partial correlation ("partial r") approach shows slight inflation, with full lm and lasso showing further inflation of Type I error.

##### distributions

```{r}
#| label: histogram variable 0

h0 <- d_0 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(type_I = mean(p_value < 0.05),
            .groups = "drop")

```

Here we view the distributions of the Type I error rate by method, beginning by isolating the p-hacked method.

```{r}
#| label: fig-histogram-phack

h0 |>
  filter(method == "p_hacked") |> 
  ggplot(aes(x = type_I)) +
  geom_histogram() +
  facet_wrap(~ method) +
  labs(x = "Type I Error",
       title = "Distribution of Type I error: p-hacked")

```

We see that while the average Type I error for the p-hacked method was `r type_I_summary$type_I[3]`, it reached as high as `r max(h0$type_I)`, further emphasizing the inflation of error. <br>

Removing this method, we can view the distributions of the remaining 6 methods.

```{r}
#| label: fig-histograms-all-0

h0 |>
  filter(method != "p_hacked") |> 
  ggplot(aes(x = type_I)) +
  geom_histogram() +
  facet_wrap(~ method) +
  labs(x = "Type I Error",
       title = "Distribution of Type I error")

```

We see that no covariates, all covariates, and r selection methods show normal distributions centered around 0.05, while partial r, full lm, and lasso are slightly right-skewed, with full lm having the greatest skew.

#### by n_obs

We will view the Type I error rates of each method for the different levels of the number of observations in a sample. In the table below, we see the minimum, maximum, and average Type I error for each level of n_obs by each method.

```{r}
#| label: tbl-typeI-nobs 

d_0 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  group_by(n_obs, method) |> 
  summarise(typeI_min = min(prop_sig),
            typeI_max = max(prop_sig),
            typeI_mean = mean(prop_sig),
            .groups = "drop") |> 
  kbl(caption = "Type I error by n_obs")

```

Looking at the average column, we see that the Type I error is not affected much for the no covariates, all covariates, r, and partial r approaches across different sample sizes. However, for p-hacked, full lm, and lasso, the Type I error does decrease as sample size increases. This can be visualized in the plot below. <br>

*Note:* For the line plots throughout this report, a solid line will indicate a method that does not involve performing selection of covariates (i.e., using no or all covariates). A dashed line will indicate a method that does involve performing a non-trivial selection of covariates. A dotted black line will indicate the expected value (if applicable). For example, here we see a dotted line at $\alpha = 0.05$, the expected Type I error rate.

```{r}
#| label: fig-typeI-nobs

d_0 |> 
  group_by(method, n_obs) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = n_obs, y = prop_sig, color = method, linetype = method)) + 
  geom_line() +
  geom_hline(yintercept = 0.05, linetype = "dotted", color = "black") +
  scale_x_continuous(breaks = c(50, 100, 150, 200, 300, 400)) +
  scale_y_continuous(breaks = c(0.05, 0.10, 0.15, 0.20)) +
  labs(y = "Type I error",
       title = "Type I error by n_obs") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

Again, we see the inflation of Type I error for p-hacking. For smaller sample sizes, we see that lasso and full lm perform worse than the other methods, but the methods become comparable as sample size increases.

#### by n_covs

We will view the Type I error rates of each method for the different number of available covariates (*Note: this is not necessarily the number of covariates included in the model.*). In the table below, we see the minimum, maximum, and average Type I error for each level of n_covs by each method.

```{r}
#| label: tbl-typeI-ncovs

d_0 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  group_by(n_covs, method) |> 
  summarise(typeI_min = min(prop_sig),
            typeI_max = max(prop_sig),
            typeI_mean = mean(prop_sig),
            .groups = "drop") |> 
  kbl(caption = "Type I error by n_covs")

```

Looking at the average column, we see that the Type I error is not affected much for the no covariates, all covariates, r, and partial r approaches across different amounts of available covariates. However, for p-hacked, full lm, and lasso, the Type I error increases as the number of covariates increases. This can be visualized in the plot below.

```{r}
#| label: fig-typeI-ncovs

d_0 |> 
  group_by(method, n_covs) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = n_covs, y = prop_sig, color = method, linetype = method)) + 
  geom_line() +
  geom_hline(yintercept = 0.05, linetype = "dotted", color = "black") +
  scale_x_continuous(breaks = c(4, 8, 12, 16, 20)) +
  scale_y_continuous(breaks = c(0.05, 0.10, 0.15, 0.20, 0.25)) +
  labs(y = "Type I error",
       title = "Type I error by n_covs") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

We see the large increase in error for the p-hacked method and the slight increase for full lm and lasso methods as the number of covariates increases, while the other methods stay around 0.05.

#### by p_good_covs

We will view the Type I error rates of each method for the different proportions of good covariates. In the table below, we see the minimum, maximum, and average Type I error for each level of p_good_covs by each method.

```{r}
#| label: tbl-typeI-pgoodcovs

d_0 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  group_by(p_good_covs, method) |> 
  summarise(typeI_min = min(prop_sig),
            typeI_max = max(prop_sig),
            typeI_mean = mean(prop_sig),
            .groups = "drop") |> 
  kbl(caption = "Type I error by p_good_covs")

```

Looking at the average column, we see that the Type I error is not affected for the no covariates, all covariates, and r approaches across different proportions. However, for p-hacked, partial r, full lm, and lasso, the Type I error changes as the number of covariates increases. This can be visualized in the plots below.

```{r}
#| label: fig-typeI-pgoodcovs

d_0 |> 
  group_by(method, p_good_covs) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = p_good_covs, y = prop_sig, color = method, linetype = method)) + 
  geom_line() +
  geom_hline(yintercept = 0.05, linetype = "dotted", color = "black") +
  scale_x_continuous(breaks = c(0.25, 0.50, 0.75)) +
  scale_y_continuous(breaks = c(0.05, 0.10, 0.15, 0.20)) +
  labs(y = "Type I error",
       title = "Type I error by p_good_covs") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In this plot, we mainly see the increase in Type I error for the p-hacking approach as the proportion of good covariates increases. As there are more good covariates, the Type I error decreases for lasso and partial r, but it increases for full lm.


#### by correlations

Recall that in these simulations, the correlation among the good covariates was held constant at 0.3. So, we will look at the Type I error rates of each method by the correlation between $Y$ and the good covariates.

```{r}
#| label: tbl-typeI-rycov

d_0 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  group_by(r_ycov, method) |> 
  summarise(typeI_min = min(prop_sig),
            typeI_max = max(prop_sig),
            typeI_mean = mean(prop_sig),
            .groups = "drop") |> 
  kbl(caption = "Type I error by y-cov correlations")

```

Looking at the average column, we see that the error does not change across correlations for the no covariates, all covariates, r, and partial r approaches. It changes slightly for full lm and lasso. And it changes drastically when p-hacking, such that a higher correlation among good covariates increases the Type I error.

```{r}
#| label: fig-typeI-rycov

d_0 |> 
  group_by(method, r_ycov) |> 
  summarise(prop_sig = mean(p_value < 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = r_ycov, y = prop_sig, color = method, linetype = method)) + 
  geom_line() +
  geom_hline(yintercept = 0.05, linetype = "dotted", color = "black") +
  scale_x_continuous(breaks = c(0.3, 0.5)) +
  scale_y_continuous(breaks = c(0.05, 0.10, 0.15, 0.20, 0.25, 0.30)) +
  labs(y = "Type I error",
       title = "Type I error by y-cov correlation") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In the plot, we see the Type I error for the p-hacking method increase as the correlation between $Y$ and the good covariates increases. The other methods remain at relatively the same Type I error rate across correlation values.

### Estimate, SD, & SE

Here we will compare, across methods, the estimate of $b_x$, the standard deviation of the estimate, and the average standard error of the estimate. The standard deviation is calculated as the SD of the sampling distribution of the estimates. The standard error is from the linear model output. Since the mean of standard errors would be biased, we calculate the average SE by taking the square root of the mean of the squared standard errors. We compare the differences by subtracting this average linear model SE from the calculated SD.

```{r}
#| label: tbl-est-sd-se-0

d_0 |> 
  group_by(method) |> 
  summarise(mean_estimate = sprintf("%.3f", mean(estimate)*-1),
            SD_estimate = sd(estimate),
            SE_mean = sqrt(mean(SE^2)),
            difference = SD_estimate - SE_mean) |> 
  kbl(caption = "b_x = 0")

```

We see that all methods have an average estimate of 0, as expected given the population value for $b_x$. We see that the standard deviation of the sampling distribution of the estimate equals the standard error for no covariates, all covariates, and r selection methods. There are small differences between these values for partial r, full lm, and lasso methods. The p-hacking shows a large difference.

### Sampling Distributions

Here we view a sampling distribution of the estimate for $b_x$ for each method.

```{r}
#| label: fig-distribution-bx-0

d_0 |> 
  ggplot(aes(x = estimate, color = method, linetype = method)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0, linetype = "dotted", color = "black") +
  scale_x_continuous(limits = c(-0.5, 0.5), breaks = seq(-0.5, 0.5, by = 0.5)) +
  labs(title = "Sampling Distribution for b_x = 0") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

We see again that each method's distribution is centered around 0, but the p-hacked method is not normally distributed as it is biasing the parameter estimates. In addition, we see that the no covariates method has more variability in its estimate for $b_x$ than the other valid selection methods. <br>

From these primary analyses, we see that the p-hacked method leads to inflated Type I error rates and biased parameter estimates. We can conclude that it is not a statistically valid method. For the following analyses, we will not include the p-hacked method. While partial r, full lm, and lasso selection methods showed slight inflation of Type I error, we might be willing to accept this for greater reductions in Type II error, which we will compare in the next section.

## Nonzero $X$ Effect

Next, we look at the nonzero $X$ effect condition to compare the Type II errors across methods and research settings. Recall that we set two values for $b_x$ of 0.3 and 0.5.

### Type II Error

We will look at the overall Type II error across methods (except p-hacked), then will again compare the error of each method across each of the manipulated variables: n_obs, n_covs, p_good_covs, r_ycov, and r_cov.

#### by method

We will first consider the Type II error by the selection method, for both $b_x = 0.3$ and $b_x = 0.5$. Here we calculate the proportion of non-significant effects ($p \geq 0.05$), the Type II error, displayed below as bar plots.

##### b_x = 0.3

```{r}
#| label: fig-typeII-bar-03

type_II_summary_03 <- d_03 |>
  filter(method != "p_hacked") |> 
  group_by(method) |>
  summarise(type_II = mean(p_value >= 0.05))

type_II_summary_03 |> 
ggplot(aes(x = method, y = type_II, fill = method)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.3f", type_II)), vjust = -0.5) +
  labs(title = "Type II error by method, b_x = 0.3",
       x = "Method",
       y = "Type II Error",
       fill = "Method") +
  scale_y_continuous(limits = c(0, max(type_II_summary_03$type_II) * 1.2), 
                     breaks = seq(0, max(type_II_summary_03$type_II) * 1.2, by = 0.05)) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = method_colors)

```

In this first plot for $b_x = 0.3$, we see that the Type II error is highest when no covariates are used in the model. There is a large reduction in Type II error when we include all covariates compared to no covariates, and a slight further reduction in Type II error when we use a selection method for covariates compared to including all.

##### distributions

```{r}
#| label: histograms variable 03

h03 <- d_03 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(type_II = mean(p_value >= 0.05),
            .groups = "drop")

```

Here we view the distributions of the Type II error rate by method, for $b_x = 0.3$.

```{r}
#| label: fig-histograms-all-03

h03 |>
  filter(method != "p_hacked") |> 
  ggplot(aes(x = type_II)) +
  geom_histogram() +
  facet_wrap(~ method) +
  labs(x = "Type II Error",
       title = "Distribution of Type II error, b_x = 0.3")

```

Aside from the no covariates approach, we see that the other methods have a similar range of Type II error.

##### b_x = 0.5

```{r}
#| label: fig-typeII-bar-05

type_II_summary_05 <- d_05 |>
  filter(method != "p_hacked") |> 
  group_by(method) |>
  summarise(type_II = mean(p_value >= 0.05))

type_II_summary_05 |> 
ggplot(aes(x = method, y = type_II, fill = method)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = sprintf("%.3f", type_II)), vjust = -0.5) +
  labs(title = "Type II error by method, b_x = 0.5",
       x = "Method",
       y = "Type II Error",
       fill = "Method") +
  scale_y_continuous(limits = c(0, max(type_II_summary_05$type_II) * 1.2), 
                     breaks = seq(0, max(type_II_summary_05$type_II) * 1.2, by = 0.05)) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = method_colors)

```

We see a similar trend as above, of a large reduction in Type II error when including all covariates compared to no covariates, and another reduction when selecting covariates, especially when using r, partial r, or lasso. <br>

##### distributions

```{r}
#| label: histograms variable 05

h05 <- d_05 |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(type_II = mean(p_value >= 0.05),
            .groups = "drop")

```

Here we view the distributions of the Type II error rate by method, for $b_x = 0.5$.

```{r}
#| label: fig-histograms-all-05

h05 |>
  filter(method != "p_hacked") |> 
  ggplot(aes(x = type_II)) +
  geom_histogram() +
  facet_wrap(~ method) +
  labs(x = "Type II Error",
       title = "Distribution of Type II error, b_x = 0.5")

```

Similarly, we see a similar range and distribution of Type II error for the selection methods, other than no covariates method.

#### by n_obs

We will view the Type II error rates of each method for the different levels of the number of observations in a sample. In the tables below, we see the minimum, maximum, and average Type II error for each level of n_obs by each method, for both $b_x = 0.3$ and $b_x = 0.5$.

##### b_x = 0.3

```{r}
#| label: tbl-typeII-nobs-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(n_obs, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by n_obs, b_x = 0.3")

```

In this table, we see that for all methods, as the sample size increases, the Type II error decreases. This can be better seen in a plot below.

```{r}
#| label: fig-typeII-nobs-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = n_obs, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(50, 100, 150, 200, 300, 400)) +
  labs(y = "Type II error",
       title = "Type II error by n_obs, b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

Here, we see the decrease in Type II error for the increase in sample size across all methods. We see that the no covariates approach has the highest Type II error. From both the table and the plot, we see that for smaller sample sizes, including all covariates in the model yields higher Type II errors, but these become comparable for larger sample sizes. <br>

##### b_x = 0.5

```{r}
#| label: tbl-typeII-nobs-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(n_obs, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by n_obs, b_x = 0.5")

```

We see lower overall Type II errors, but the same trend of decreasing errors for increasing sample sizes across all methods. We can view this in the plot below.

```{r}
#| label: fig-typeII-nobs-05

d_05 |> 
  filter(method != "p_hacked") |>
  group_by(method, n_obs) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = n_obs, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(50, 100, 150, 200, 300, 400)) +
  labs(y = "Type II error",
       title = "Type II error by n_obs, b_x = 0.5") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

Similarly, the no covariates approach has the highest Type II error. For small sample sizes the all covariates approach has higher error which stabilizes with increasing sample size.

#### by n_covs

We will view the Type II error rates of each method for the different number of available covariates. In the tables below, we see the minimum, maximum, and average Type II error for each level of n_covs by each method, for both $b_x = 0.3$ and $b_x = 0.5$.

##### b_x = 0.3

```{r}
#| label: tbl-typeII-ncovs-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(n_covs, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by n_covs, b_x = 0.3")

```

From the average column, we can see that Type II error decreases as the number of covariates increases across all methods, except the no covariates method as this does not dependent on the number of covariates. We can see these trends in the plot below.

```{r}
#| label: fig-typeII-ncovs-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_covs) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = n_covs, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(4, 8, 12, 16, 20)) +
  labs(y = "Type II error",
       title = "Type II error by n_covs, b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In this plot, as the number of covariates increases, we see larger reductions in Type II error when selecting the covariates compared to including all available covariates. Lasso performs the best with higher numbers of covariates, followed by partial r, r, and full lm in order. Again, using no covariates yields the highest Type II error.

##### b_x = 0.5

```{r}
#| label: tbl-typeII-ncovs-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(n_covs, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by n_covs, b_x = 0.5")

```

We see the same decrease in Type II errors for increases in number of covariates. We can visualize this in the plot below.

```{r}
#| label: fig-typeII-ncovs-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_covs) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = n_covs, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(4, 8, 12, 16, 20)) +
  labs(y = "Type II error",
       title = "Type II error by n_covs, b_x = 0.5") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

Similarly, we see the selection methods performing better than using all covariates. For higher numbers of covariates, we see lasso has the lowest Type II error, followed by partial r, r, and full lm. Using no covariates yields the highest Type II error.

#### by p_good_covs

We will view the Type II error rates of each method for the different proportions of "good" covariates. In the table below, we see the minimum, maximum, and average Type II error for each level of p_good_covs by each method, for both $b_x = 0.3$ and $b_x = 0.5$.

##### b_x = 0.3

```{r}
#| label: tbl-typeII-pgoodcovs-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(p_good_covs, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by p_good_covs, b_x = 0.3")

```

From the average column, we see decreases in Type II error rates for increases in the proportion of good covariates across all methods -- except no covariates, as this is independent of the proportion of good covariates. We can visualize the trends more clearly in the plot below.

```{r}
#| label: fig-typeII-pgoodcovs-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, p_good_covs) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = p_good_covs, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(0.25, 0.50, 0.75)) +
  labs(y = "Type II error",
       title = "Type II error by p_good_covs, b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In addition to the decrease in error mentioned above, we see that including all covariates has a higher Type II error than selection the covariates, especially for lower proportions of good covariates. For larger proportions of good covariates, we see that lasso has the lowest Type II error and that using all covariates and full lm become comparable.

##### b_x = 0.5

```{r}
#| label: tbl-typeII-pgoodcovs-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(p_good_covs, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by p_good_covs, b_x = 0.5")

```

From the table, we see decreases in Type II error for higher proportions of good covariates for methods that do include covariates. We can see the details in the plot below.

```{r}
#| label: fig-typeII-pgoodcovs-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, p_good_covs) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = p_good_covs, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(0.25, 0.50, 0.75)) +
  labs(y = "Type II error",
       title = "Type II error by p_good_covs, b_x = 0.5") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

We again see that including all covariates has a higher Type II error rate than selecting covariates to include, although this method improves for higher proportions of good covariates. Partial r performs best for a lower proportion of good covariates while lasso performs best for a higher proportion. Similarly, full lm and all covariates approaches become comparable as the proportion increases.


#### by correlations

Recall that in these simulations, the correlation among the good covariates was held constant at 0.3. So, we will look at the Type II error rates of each method by the correlation between $Y$ and the good covariates, for both $b_x = 0.3$ and $b_x = 0.5$.

##### b_x = 0.3

```{r}
#| label: tbl-typeII-rycov-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(r_ycov, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by correlations, b_x = 0.3")

```

In the table, we see that the Type II error decreases as the correlation between $Y$ and the good covariates increases. The Type II error is highest for including no covariates. We can visualize this below.

```{r}
#| label: fig-typeII-rycov-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method, r_ycov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = r_ycov, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(0.3, 0.5)) +
  labs(y = "Type II error",
       title = "Type II error by y-cov correlation, b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In the plots, we see that the no covariates method has the highest Type II error across correlation levels. The Type II errors decrease as the correlation between $Y$ and the good covariates increases. We also see slight decreases in Type II error from including all covariates to selecting them.

##### b_x = 0.5

```{r}
#| label: tbl-typeII-rycov-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, n_obs, n_covs, r_ycov, p_good_covs, r_cov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  group_by(r_ycov, method) |> 
  summarise(typeII_min = min(prop_not_sig),
            typeII_max = max(prop_not_sig),
            typeII_mean = mean(prop_not_sig),
            .groups = "drop") |> 
  kbl(caption = "Type II error by correlations, b_x = 0.5")

```

From the table, we see that the Type II error decreases as the correlation between $Y$ and the good covariates increases.

```{r}
#| label: fig-typeII-rycov-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method, r_ycov) |> 
  summarise(prop_not_sig = mean(p_value >= 0.05),
            .groups = "drop") |> 
  ggplot(aes(x = r_ycov, y = prop_not_sig, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(0.3, 0.5)) +
  labs(y = "Type II error",
       title = "Type II error by y-cov correlation, b_x = 0.5") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In the plot, we see again that the no covariates approach has the highest Type II error across correlations. There is a slight decrease in Type II error when selecting covariates instead of using all covariates. Among the selection methods, full lm has the higher Type II error for a lower $Y$-covariate correlation, but the errors become comparable for a higher correlation.

### Estimate, SD, & SE

Here we will compare, across methods, the estimate of $b_x$, the standard deviation of the estimate, and the average standard error of the estimate. The standard deviation is calculated as the SD of the sampling distribution of the estimates. The standard error is from the linear model output. Since the mean of standard errors would be biased, we calculate the average SE by taking the square root of the mean of the squared standard errors. We compare the differences by subtracting this average linear model SE from the calculated SD.

#### b_x = 0.3

```{r}
#| label: tbl-est-sd-se-03

d_03 |> 
  filter(method != "p_hacked") |> 
  group_by(method) |> 
  summarise(mean_estimate = mean(estimate),
            SD_estimate = sd(estimate),
            mean_SE = sqrt(mean(SE^2)),
            difference = SD_estimate - mean_SE) |> 
  kbl(caption = "Estimate, SD, SE: b_x = 0.3")

```

Here we see that all methods correctly estimate $b_x$ to be 0.3, except the r approach which yielded a slightly lower average estimate. The no covariates, all covariates, and r approaches show no difference between the calculated SD and the linear model SE, while partial r, full lm, and lasso approaches show slight differences.

#### b_x = 0.5

```{r}
#| label: tbl-est-sd-se-05

d_05 |> 
  filter(method != "p_hacked") |> 
  group_by(method) |> 
  summarise(mean_estimate = mean(estimate),
            SD_estimate = sd(estimate),
            mean_SE = sqrt(mean(SE^2)),
            difference = SD_estimate - mean_SE) |> 
  kbl(caption = "Estimate, SD, SE: b_x = 0.5")

```

Similarly, we see all methods correctly estimate $b_x$ to be 0.5, except the r approach which again yielded a slightly lower estimate. The no covariates, all covariates, and r approaches show no difference between the calculated SD and the linear model SE, while partial r, full lm, and lasso approaches show slight differences.

### Sampling Distributions

Here we view sampling distributions of the estimate for $b_x$ for each method, for both $b_x = 0.3$ and $b_x = 0.5$.

#### b_x = 0.3

```{r}
#| label: fig-distribution-bx-03

d_03 |> 
  filter(method != "p_hacked") |> 
  ggplot(aes(x = estimate, color = method, linetype = method)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0.3, linetype = "dotted") +
  scale_x_continuous(limits = c(-0.2, 0.8), breaks = c(0, 0.3, 0.6)) +
  labs(title = "Sampling Distribution for b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In the plot, we can see that the distributions for all methods are centered around 0.3. The no covariates approach again has the widest distribution.

#### b_x = 0.5

```{r}
#| label: fig-distribution-bx-05

d_05 |> 
  filter(method != "p_hacked") |> 
  ggplot(aes(x = estimate, color = method, linetype = method)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0.5, linetype = "dotted") +
  scale_x_continuous(limits = c(0, 1), breaks = c(0, 0.5, 1)) +
  labs(title = "Sampling Distribution for b_x = 0.5") + 
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

In the plot, we can see that the distributions for all methods are centered around 0.5. The no covariates approach again has the widest distribution. <br>

From these secondary analyses, we see that using no covariates leads to the highest Type II error rates across research settings. Using all covariates provides reduction in Type II error (and thus, more power), but using a non-trivial selection method leads to further reductions in Type II error.

## Good covariates true positive & false positive rates

Finally, we will look at the true positive rate (TPR) and false positive rate (FPR) for including good covariates by each method to compare how well each method found/included covariates that were part of the data generating process. Ideally, we want a high TPR, indicating that the method had a high proportion of finding/including the good covariates. We want a low FPR, indicating that the method had a low proportion of including the bad covariates. These rates are displayed in the tables below. We include the p-hacked method again. <br>

It also makes sense to consider the TPR & FPR of including good covariates while also considering the actual number of good covariates. We will look at plots of these below as well for $b_x = 0, 0.3, 0.5$.

### True Positive Rate (TPR)

#### b_x = 0

```{r}
#| label: tbl-tpr-0

d_0 |> 
  group_by(method) |> 
  summarise(covs_tpr_mean = sprintf("%.3f", mean(covs_tpr)),
            .groups = "drop") |> 
  kbl(caption = "TPR, b_x = 0")

```

On average, we see that r, partial r, and lasso perform the best, while full lm has a considerably lower TPR.

```{r}
#| label: fig-tpr-0

d_0 |> 
  mutate(n_good_covs = n_covs * p_good_covs) |> 
  group_by(method, n_good_covs) |> 
  summarise(covs_tpr_mean = mean(covs_tpr),
            .groups = "drop") |> 
  ggplot(aes(x = n_good_covs, y = covs_tpr_mean, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15)) +
  labs(y = "True Positive Rate",
       title = "TPR by n_good_covs, b_x = 0") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

As the number of good covariates increases, we see that full lm has a large decrease in the TPR and lasso has a smaller decrease. The other methods remain relatively stable. We see that the p-hacked method has a relatively flat rate of 50%, indicating that it finds only half of the good covariates.

#### b_x = 0.3

```{r}
#| label: tbl-tpr-03

d_03 |> 
  group_by(method) |> 
  summarise(covs_tpr_mean = sprintf("%.3f", mean(covs_tpr)),
            .groups = "drop") |> 
  kbl(caption = "TPR, b_x = 0.3")

```

Similarly, r, partial r, and lasso methods have a higher TPR than full lm.

```{r}
#| label: fig-tpr-03

d_03 |> 
  mutate(n_good_covs = n_covs * p_good_covs) |> 
  group_by(method, n_good_covs) |> 
  summarise(covs_tpr_mean = mean(covs_tpr),
            .groups = "drop") |> 
  ggplot(aes(x = n_good_covs, y = covs_tpr_mean, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15)) +
  labs(y = "True Positive Rate",
       title = "TPR by n_good_covs, b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

We see a similar trend in large decreases for full lm and smaller decreases for lasso in the TPR as the number of good covariates increases.

#### b_x = 0.5

```{r}
#| label: tbl-tpr-05

d_05 |> 
  group_by(method) |> 
  summarise(covs_tpr_mean = sprintf("%.3f", mean(covs_tpr)),
            .groups = "drop") |> 
  kbl(caption = "TPR, b_x = 0.5")

```

Again we see that r, partial r, and lasso perform the best. In this case with a larger $X$ effect, we see partial r starting to outperform the r method in terms of TPR.

```{r}
#| label: fig-tpr-05

d_05 |> 
  mutate(n_good_covs = n_covs * p_good_covs) |> 
  group_by(method, n_good_covs) |> 
  summarise(covs_tpr_mean = mean(covs_tpr),
            .groups = "drop") |> 
  ggplot(aes(x = n_good_covs, y = covs_tpr_mean, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15)) +
  labs(y = "True Positive Rate",
       title = "TPR by n_good_covs, b_x = 0.5") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

We see the same decreases in TPR for full lm and lasso as the number of good covariates increases.

### False Positive Rate (FPR)

#### b_x = 0

```{r}
#| label: tbl-fpr-0

d_0 |> 
  group_by(method) |> 
  summarise(covs_fpr_mean = sprintf("%.3f", mean(covs_fpr)),
            .groups = "drop") |> 
  kbl(caption = "FPR, b_x = 0")

```

For the FPR, we see that r, partial r, and full lm are all comparable, while lasso performs worse than these methods.

```{r}
#| label: fig-fpr-0

d_0 |> 
  mutate(n_good_covs = n_covs * p_good_covs) |> 
  group_by(method, n_good_covs) |> 
  summarise(covs_fpr_mean = mean(covs_fpr),
            .groups = "drop") |> 
  ggplot(aes(x = n_good_covs, y = covs_fpr_mean, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15)) +
  labs(y = "False Positive Rate",
       title = "FPR by n_good_covs, b_x = 0") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

We see that as the number of good covariates increases, most methods remain stable in their FPR, except for lasso.

#### b_x = 0.3

```{r}
#| label: tbl-fpr-03

d_03 |> 
  group_by(method) |> 
  summarise(covs_fpr_mean = sprintf("%.3f", mean(covs_fpr)),
            .groups = "drop") |> 
  kbl(caption = "FPR, b_x = 0.3")

```

Similarly, r, partial r, and full lm are all comparable, while lasso performs worse than these methods.

```{r}
#| label: fig-fpr-03

d_03 |> 
  mutate(n_good_covs = n_covs * p_good_covs) |> 
  group_by(method, n_good_covs) |> 
  summarise(covs_fpr_mean = mean(covs_fpr),
            .groups = "drop") |> 
  ggplot(aes(x = n_good_covs, y = covs_fpr_mean, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15)) +
  labs(y = "False Positive Rate",
       title = "FPR by n_good_covs, b_x = 0.3") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

The valid selection methods are again comparable, except for lasso which has a changing FPR as the number of good covariates increases.

#### b_x = 0.5

```{r}
#| label: tbl-fpr-05

d_05 |> 
  group_by(method) |> 
  summarise(covs_fpr_mean = sprintf("%.3f", mean(covs_fpr)),
            .groups = "drop") |> 
  kbl(caption = "FPR, b_x = 0.5")

```

Again we have that r, partial r, and full lm are all comparable, while lasso performs worse and is close to the performance of p-hacking.

```{r}
#| label: fig-fpr-05

d_05 |> 
  mutate(n_good_covs = n_covs * p_good_covs) |> 
  group_by(method, n_good_covs) |> 
  summarise(covs_fpr_mean = mean(covs_fpr),
            .groups = "drop") |> 
  ggplot(aes(x = n_good_covs, y = covs_fpr_mean, color = method, linetype = method)) + 
  geom_line() +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15)) +
  labs(y = "False Positive Rate",
       title = "FPR by n_good_covs, b_x = 0.5") +
  scale_linetype_manual(values = method_linetypes) +
  scale_color_manual(values = method_colors)

```

The lasso method shows the same trend in FPR here, while the other methods remain stagnant.

# Conclusions

We compared 7 methods for selecting covariates to include in linear models. In the first section looking at Type I errors, we demonstrated that the p-hacking approach is not a statistically valid method as it led to inflated Type I error rates and biased parameter estimates (@fig-distribution-bx-0). The remaining 6 methods were all shown to be statistically valid, although partial r, lasso, and full lm showed slight inflation of Type I error (@fig-typeI-bar). The methods can be further compared by their Type II error results. Overall, using no covariates performed the worst as it led to the highest Type II error (and thus, has the lowest power). The no covariates method also showed more variability in the estimate for $b_x$ (@fig-distribution-bx-0, @fig-distribution-bx-03, @fig-distribution-bx-05). Including all covariates led to reductions in Type II error, and using one of the selection methods led to further reductions in Type II error.

The Type II error of the selection methods can be looked at more closely for different research settings. For smaller sample sizes, we see the benefit of using a selection method over using all covariates (@fig-typeII-nobs-03, @fig-typeII-nobs-05). Lasso yielded slightly inflated Type I error, but it performs best for larger numbers of covariates (@fig-typeII-ncovs-03, @fig-typeII-ncovs-05) and for larger proportions of good covariates (@fig-typeII-pgoodcovs-03, @fig-typeII-pgoodcovs-05). This can be further seen when looking at the number of good covariates where we again see lasso outperform the other methods. However, we do see that as the number of good covariates increases, the true positive rate of lasso including these good covariates decreases compared to r and partial r (@fig-tpr-0). While the bivariate correlation method shows no inflation of Type I error, it does underestimate $b_x$ for both $b_x = 0.3$ (@tbl-est-sd-se-03) and $b_x = 0.5$ (@tbl-est-sd-se-05). While the partial correlation method does show slight inflation of Type I error, it correctly estimates $b_x$. For smaller correlations between $Y$ and the covariates, we again see the benefit of selecting covariates rather than using all, especially for a larger $X$ effect (@fig-typeII-rycov-05). Among the valid non-trivial selection methods, we see that full lm leads to the highest Type I error. When considering larger numbers of good covariates, we see the Type II error increasing for full lm, which in some cases, performed even worse than all covariates. 

Overall, we can narrow the options for selection methods to bivariate correlation, partial correlation, full lm, and lasso. One of these methods may show more benefits to power depending on the research context. While they each have advantages and disadvantages, researchers should also consider the complexity of these methods when weighing the possible options for selecting covariates.
